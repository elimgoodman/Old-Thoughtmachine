- Possibility space
- Autocomplete
- Visual studio/the windows + .net ecosystem 
- Smalltalk
- OMeta
- Language workbenches
- That canadian CS professor video about using research to determine good engineering practices
- The mathematical origins of programming (math uses abstraction to move further from reality, programming uses abstraction to move from the physical towards the useful/"real")
- Is more software a good thing? (ie, is definitely good to make programming easier?)
- Deployd
- Backlift
- Handcraft
- Yeoman/Bower
- JS Components
- Bundlescout
- Imagining a dream programming environment
    - what's good about vim
    - what's good about emacs
    - spreadsheet-ness
    - API and library awareness (snapping together the lego pieces)
- Microsoft Access/Filemaker - DB-centric "programming" environments
- APL
- http://paulcollier.ca/
- http://www.tiledtext.com/
- Live Programming
- UX in programming environments
- No silver bullet
- Resharper
- Core hypothesis: apply prod dev methodology to programming
- What would build measure learn look like for a coding tool?
- The whole widget
- Advances in libraries and frameworks
- The fundamental act of programming is typing
- Cathedral and bazaar
- Unix as IDE 
- The spreadsheet
- http://runnable.com/
- http://webshell.io/
- http://hackety.com/, http://shoesrb.com/
- Graphical programming languages
    - http://scratch.mit.edu/
    - Blockly: https://code.google.com/p/blockly
- DSLs vs layers of abstractions -- can we pinpoint the difference and decide which could be a way forward?
- Canonical examples to see if we're making progress
    - Simple poll app
    - Blog
    - Photo album
    - 3 Photos, 3 Questions (http://three-photos-three-questions.herokuapp.com/)
- Creating lots of RESTful building blocks scattered around the internet (languages would become just control logic calling out to external services)
- Code Bubbles
- RDF

- The idea for the little crew of monsters iPad app programming game
    - have a narrative

- The story of programming is the story of "mostly the same, but different"
    - functions are mostly the same commands, with different parameters
    - objects are mostly the same functionality with different internal state
    - inheritance creates classes that are mostly the same with some different functionality or pieces of state
    - macros create blocks of code that are mostly the same with different params
    - what would something to create whole programs that are mostly the same but different look like?
    - or, if not whole programs, doing this at a much higher level?
    - what about an editor that we geared towards this concept?

- programs and libraries use forking - what if everything used the same system?

- Wolfram alpha

- http://amber-lang.net/

- Programmers won't fix programming
    - the programmers mindset got us here - applying "more of the same" won't get us out
    - all we can see are the advantages of the current system
    - it will take the inclusion of other disciplines and the application of existing prod dev methodologies to move the industry forward

- Programming's eroding kingdom
    - if programming is hard, the easiest way to make the way world better is to simply have less of it

- "Solving hard problems"
    - there is a wanker-y, rubik's cube mentality where engineers want to work on solipsistic piece of puzzle work, divorced from reality and filled with obscurity. programmers like challenges, and thus hate things that deprive them of challenges. see: drupal
    - we should be constantly trying to put ourselves out of a job, but that's hard for people to deal with

- Why is programming hard, anyways?
    - lots to remember
    - lots to understand
       - understanding is predicated on design, but the world of programming is very undersigned 
        - understanding = building models
            - takes insane dicipline
            - working with different models is super painful
                - different libraries
                - different authors of the same codebase
            - models change over time - refactoring is painful
    - statefulness
    - a lot of typing (the computer doesn't help you)
    - types
    - runtime errors
    - complexity
    - translation error (it's different in your head than in the program)
    - tools are fucking horrible to use, ugly, clunky, huge learning curve

- http://icecoder.net/

- livecoding.io

- http://tributary.io/

- https://github.com/shurcooL/Conception

- http://www.subtextual.org/

- http://alarmingdevelopment.org/?p=5

- http://aspen.io/

- http://research.microsoft.com/en-us/projects/codecanvas/

- https://www.fivetran.com/

- Design patterns

- http://www.visual-paradigm.com/

- http://playground.webflow.com/?s=hn

- Which companies are tackling this problem?
	- jetbrains
	- apple
	- microsoft
	- google
	- sublime text
