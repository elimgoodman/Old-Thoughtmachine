---
layout: post
title: "What Makes Programming Hard? Part 2"
description: "It's all concepts."
category: 
tags: []
published: true
discoverable: false
author: eli
---
{% include JB/setup %}

In my [previous post](http://thoughtmachine.co/what-makes-programming-hard-pt-1/), I started talking about what makes programming so dang hard to begin with. I'd like to continue in this vein.

###Problem #2: Programming forces people to learn a number of lot of concepts that don't fit together all that well.

When I'm programming, I have to keep a fuckload of different concepts in my head - concepts from the language, the libraries I'm using, and my own codebase. Let's call all of these things (language features, libraries, and objects/functions in my project's codebase) *programming entities*. The way I understand things is to build a mental model of the entity, and then query that model for information. However, in order to store a meaningful model in my head, the entity actually has to be pretty simple, and not have that many exceptions, or even rules. Simple things are easier to understand. In order to be simple enough to make into a meaningful mental model, the thing being modeled has to be well designed. *Design* is the crucial element that makes things modelable. And coherent design is a rare thing in most computer programs. I think this is a function of a couple of factors. 

### Refactoring is hard

With most current programming tools and languages, refactoring is a difficult and dangerous thing to do. 
Refactoring requires a view of the "whole system"
Refactoring is time consuming and yields no immediate benefit

### Standardization is rare
cathedral vs bazaar
### The hacker ethos is prevelant



// Design patterns?